---
title: "Final_Exam"
author: "Salma Elshahawy"
date: "5/11/2020"
output: 
  html_document:
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: true
    df_print: paged
  pdf_document:
    extra_dependencies: geometry
    keep_tex: yes
    latex_engine: xelatex
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction

Your final is due by the end of the last week of class.  You should post your solutions to your GitHub account or RPubs.  You are also expected to make a short presentation via YouTube  and post that recording to the board.  This project will show off your ability to understand the elements of the class.

## Problem 1

Using R, generate a random variable X that has 10,000 random uniform numbers from 1 to N, where N can be any number of your choosing greater than or equal to 6.  

```{r}
set.seed(123)
N <- runif(1, 8, 1000)
n <- 10000
X <- runif(n, min = 0, max = N)

```

Then generate a random variable Y that has 10,000 random normal numbers with a mean of $μ=σ=(N+1)/2$.

```{r}
set.seed(123)
me <- (N+1)/2
sd <- me
Y <- rnorm(n, mean = me, sd = sd)

```


**Probability.**  Calculate as a minimum the below probabilities a through c. Assume the small letter "x" is estimated as the median of the X variable, and the small letter "y" is estimated as the 1st quartile of the Y variable.  Interpret the meaning of all probabilities.

```{r}
(x <- median(X))
(y <- quantile(Y, 0.25)[[1]])
```

- a.   P(X>x | X>y)

$$P(X>x | X>y) = \frac{P(X>145.0453) \quad& P(X>48.85452) }{P(X>48.85452)}$$


```{r}
(p_a <- sum(X>x & X>y)/n)
(p_xy <- sum(X>y)/n) 
(p_a/p_xy)
```
0.6 is the probability that X is **greater than** its median given that X is **greater than** the first quartile of Y.

- b. P(X>x , Y>y)

$$P(X>x , X>y) = {P(X>145.0453) . P(Y>48.85452) }$$

```{r}
(p_b <- sum(X>x & Y>y)/n)
```

0.36 is the probability that X and Y are **greater than** all possible x and y. 

- c. P(X<x | X>y)

$$P(X<x | X>y) = \frac{P(X<145.0453) . P(X>48.85452) }{P(X>48.85452)}$$


```{r}
(p_c <- sum(X<x & X>y)/n)
(p_xy <- sum(X>y)/n) 
(p_c/p_xy)
```

0.39 is the probability of X **less than** its median **and greater than** the first quantile of Y.


Investigate whether $P(X>x \quad and \quad  Y>y)=P(X>x)P(Y>y)$ by building a table and evaluating the marginal and joint probabilities.

```{r}
(res <- matrix(c(sum(X>x & Y<y),sum(X>x & Y>y), sum(X<x & Y<y),sum(X<x & Y>y)),  ncol = 2, nrow = 2))
res <- cbind(res,c(res[1,1] + res[1,2], res[2,1] + res[2,2]))
res <- rbind(res,c(res[1,1] + res[2,1], res[1,2] + res[2,2], res[1,3] + res[2,3]))
(results <- as.data.frame(res))
results
colnames(results) <- c("X>x", "X<x", "total")
rownames(results)  <- c("Y<y", "Y>y", "total")

results
```

Probability matrix 

```{r}
(prob_tab <- results/n)
```

Check $P(X>x \quad and \quad  Y>y)=P(X>x)P(Y>y)$
Check the right side : $P(X>x)P(Y>y)$ from the table we get

```{r}
(round(0.5*0.75, 2))
```

Check the leftside: $P(X>x \quad and \quad  Y>y)$ from the table = 0.369 ~ 0.38

Since the results are so similar we can conclude that both X and Y are independent variable

Check to see if independence holds by using Fisher’s Exact Test and the Chi Square Test.  What is the difference between the two? Which is most appropriate?

```{r}
fisher.test(results,simulate.p.value=TRUE)
```


```{r}
chisq.test(results, correct=TRUE)
```

**"Fisher's exact test"** is a test for comparing two proportions that is conditional on the marginal frequencies. The test is exact in guaranteeing that the type I error is less than or equal to what you specify. It can however be much less. P-values are too large and power is lost. In this sense ordinary **chi-square tests** are generally "more accurate" than "exact" tests. In addition, the old adage that chi-square tests are not accurate if an expected cell frequency is less than 5 is not correct.

## Problem 2

```{r message=FALSE, warning=FALSE}
library('ggplot2')
library('ggthemes') 
library('scales')
library('dplyr') 
library('mice')
library('randomForest') 
library('data.table')
library('gridExtra')
library('corrplot') 
library('GGally')
library('e1071')
```

loading dataset 

```{r}
library(RCurl)
train <- read.csv('https://raw.githubusercontent.com/salma71/houses_prices_kaggle/master/datasets/train.csv', stringsAsFactors = F)
head(train)
colnames(train)
```

Identify the target variable which is the SalePrice

```{r}
target <- train$SalePrice
summary(target)
```

## Univariate analysis

```{r}
dim(train)
str(train)
```


```{r}
sum(sapply(train[,1:81], typeof) == "character")

#Count the number of columns that consists of numerical data

sum(sapply(train[,1:81], typeof) == "integer")
```

We have 43 columns that consist of text and 38 columns are numerical.let’s take a look at some descriptive statistics

```{r}
# Obtain summary statistics

summary(train[,sapply(train[,1:81], typeof) == "integer"])
```

As we can see from the summary statistics above, there are some outliers needs to be proceessed. It would be clear to identify which dependant variables that need processing after visualization.

```{r}
# The percentage of data missing in train

cat(sprintf("Percentage of missing values in the overall train dataset: %s%s\n", round(length(which(is.na(train) == TRUE)) * 100 / (nrow(train) * ncol(train)), 2), "%"))
```

## Visualization 

Creating one training dataset with categorical variable and one with numeric variable. We will use this for data visualization.

```{r}
cat_var <- names(train)[which(sapply(train, is.character))]
cat_car <- c(cat_var, 'BedroomAbvGr', 'HalfBath', ' KitchenAbvGr','BsmtFullBath', 'BsmtHalfBath', 'MSSubClass')
numeric_var <- names(train)[which(sapply(train, is.numeric))]
train1_cat<-train[cat_var]
train1_num<-train[numeric_var]
```

```{r}
library(ggplot2)
## Bar plot/Density plot function

## Bar plot function

plotHist <- function(data_in, i) 
{
  data <- data.frame(x=data_in[[i]])
  p <- ggplot(data=data, aes(x=factor(x))) + stat_count() + xlab(colnames(data_in)[i]) + theme_light() + 
    theme(axis.text.x = element_text(angle = 90, hjust =1))
  return (p)
}

## Density plot function

plotDen <- function(data_in, i){
  data <- data.frame(x=data_in[[i]], SalePrice = data_in$SalePrice)
  p <- ggplot(data= data) + geom_line(aes(x = x), stat = 'density', size = 1,alpha = 1.0) +
    xlab(paste0((colnames(data_in)[i]), '\n', 'Skewness: ',round(skewness(data_in[[i]], na.rm = TRUE), 2))) + theme_light() 
  return(p)
  
}

## Function to call both Bar plot and Density plot function

doPlots <- function(data_in, fun, ii, ncol=3) 
{
  pp <- list()
  for (i in ii) {
    p <- fun(data_in=data_in, i=i)
    pp <- c(pp, list(p))
  }
  do.call("grid.arrange", c(pp, ncol=ncol))
}
```

The bar plots below offer more insight into the data. MSZoning: bar plot indicates that majority of the houses are located in low density residential areas and medium density residential area.

The type of road access to the property tends to be paved and the houses do not have alleys.

Landcontour: the houses are built on flat properties
Utilities: Almost all homes have all public utilities (E,G,W, & S)
LandSlope: most of the properties have a gentle slope

```{r, fig.width=10, fig.height= 10}
## Barplots for the categorical features

doPlots(train1_cat, fun = plotHist, ii = 1:11, ncol = 4)
doPlots(train1_cat, fun = plotHist, ii = 12:22, ncol = 4)
```

The houses that have sever landslope are located in the Clear Creek and Timberland. The houses with moderate landslope are present in more neighborhood. The Clear Creek and the Crawford neighborhoods seem to have high slopes.

```{r}
train %>% 
  select(LandSlope, Neighborhood, SalePrice) %>% 
  filter(LandSlope == c('Sev', 'Mod')) %>% 
  arrange(Neighborhood) %>% 
  group_by(Neighborhood, LandSlope) %>% 
  summarize(Count = n()) %>% 
  ggplot(aes(Neighborhood, Count)) + 
  geom_bar(aes(fill = LandSlope), position = 'dodge', stat = 'identity') + 
  theme_light() + 
  theme(axis.text.x = element_text(angle = 90, hjust =1))
```


```{r,  fig.width=4, fig.height=2.5}
ggplot(train, aes(x = Neighborhood, y = SalePrice)) +
  geom_boxplot() +
  geom_hline(aes(yintercept=80), 
             colour='red', linetype='dashed', lwd=2) +
  scale_y_continuous(labels=dollar_format()) +
  theme(axis.text.x = element_text(angle = 90))
```

Boxplot between the neighboorhoods and sale price shows that BrookSide and South & West of Iowa State University have cheap houses. While Northridge and Northridge Heights are rich neighborhoods with several outliers in terms of price.


```{r, fig.width=10, fig.height= 11}
doPlots(train1_num, fun = plotDen, ii = 2:23, ncol = 4)
```


```{r, fig.width=8, fig.height=8}
library(psych)
correlations <- cor(na.omit(train1_num[,-1])) # omit the id
row_indic <- apply(correlations, 1, function(x) sum(x > 0.3 | x < -0.3) > 1)
correlations<- correlations[row_indic ,row_indic ]
corrplot(correlations, method="square")

ggcorr(correlations, palette = "RdBu", label = TRUE)
```

```{r}
# mat : is a matrix of data
# ... : further arguments to pass to the native R cor.test function
cor.mtest <- function(mat, ...) {
    mat <- as.matrix(mat)
    n <- ncol(mat)
    p.mat<- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
        for (j in (i + 1):n) {
            tmp <- cor.test(mat[, i], mat[, j], ...)
            p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
        }
    }
  colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
  p.mat
}
# matrix of the p-value of the correlation
p.mat <- cor.mtest(train1_num[,-1])
(p.mat[, 1:5])

```

```{r, fig.width=8, fig.height=8}
# Leave blank on no significant coefficient
corrplot(correlations, type="upper", order="hclust", 
         p.mat = p.mat, sig.level = 0.05, method = 'pie' ,insig = "blank")
```

## scatterplot for the most significance variables with the target(SalesPrice)

```{r message=FALSE, warning=FALSE, fig.width=10, fig.height=10}
plotCorr <- function(data_in, i){
  data <- data.frame(x = data_in[[i]], SalePrice = data_in$SalePrice)
  p <- ggplot(data, aes(x = x, y = SalePrice)) + 
    geom_point(shape = 1, na.rm = TRUE) + 
    geom_smooth(method = lm ) + 
    xlab(paste0(colnames(data_in)[i], '\n', 'R-Squared: ', round(cor(data_in[[i]], data$SalePrice, use = 'complete.obs'), 2))) + 
    theme_light()
  return(suppressWarnings(p))
}


highcorr <- c(names(correlations[,'SalePrice'])[which(correlations[,'SalePrice'] > 0.5)], names(correlations[,'SalePrice'])[which(correlations[,'SalePrice'] < -0.2)])
 
data_corr <- train[,highcorr]


doPlots(data_corr, fun = plotCorr, ii = 1:11)
```

The histogram for the response variable SalePrice shows that it is skewed. Taking the log of the variable normalizes it.


```{r message=FALSE, warning=FALSE}
library(scales)
ggplot(train, aes(x=SalePrice)) + 
  geom_histogram(col = 'white') + 
  theme_light() + 
  scale_x_continuous(labels = comma)
```

```{r}
#Normalize distribution
ggplot(train, aes(x=log(SalePrice+1))) + 
  geom_histogram(col = 'white') + 
  theme_light()
```


```{r message=FALSE, warning=FALSE, fig.width=5, fig.height=5}

signif_col <- train1_num %>%
  select(YearBuilt, FullBath, OverallQual, GrLivArea, TotRmsAbvGrd, X2ndFlrSF, SalePrice)
# options(repr.plot.width = 20, repr.plot.height = 20)
ggpairs(signif_col)
```

## The correlation plot

```{r}
corr <- train1_num %>%
  select(SalePrice, TotRmsAbvGrd, GrLivArea)
ggcorr(tidyr::drop_na(corr), palette = "RdBu", label = TRUE)
```

Test the hypotheses:

- H0: The correlation is zero.
- H1: The correlation is not zero.
- Significance level is 0.05.

```{r}
(tot_vs_sal <- cor.test(corr$TotRmsAbvGrd, corr$SalePrice, method = 'pearson'))
(gr_vs_tot <- cor.test(corr$GrLivArea, corr$TotRmsAbvGrd, method = 'pearson'))
(gr_vs_sal <- cor.test(corr$GrLivArea, corr$SalePrice, method = 'pearson'))
```


The p-value in the three varaibles is below significance level of 0.05 - around 2.2e-16. This implies that the correlation falls within the c(0.8, 0.2) confidence interval and we failed to accept the null **hypothese** which assumes that the correlation is zero.

The 80% confidence interval

```{r message=FALSE, warning=FALSE}
library(psychometric)
(CIr(r = tot_vs_sal$estimate, n = nrow(corr), level = 0.8))
(CIr(r = gr_vs_sal$estimate, n = nrow(corr), level = 0.8))
(CIr(r = gr_vs_tot$estimate, n = nrow(corr), level = 0.8))
```



To calculate the familywize error (type-I error) $FWE <= 1-(1-alpha)^c$ where:  
1. $alpha$ is the alpha level for an individual test - in this case it is 0.05. 
2. $c$ is the number of comparisons, which is 3.

```{r}
perc <- (1 - (1 - 0.05)^3)
cat(sprintf("The probability of a type-I error is : %s%s\n", perc, " "))
```

Yes, I would be worry about that probability, which is very high considering only three tests were performed.

## Linear Algebra and Correlation 

Invert your correlation matrix from above. (This is known as the precision matrix and contains variance inflation factors on the diagonal.) Multiply the correlation matrix by the precision matrix, and then multiply the precision matrix by the correlation matrix. Conduct LU decomposition on the matrix.

```{r}
cor_mat <- data.matrix(cor(corr))
rownames(cor_mat) <- c()
colnames(cor_mat) <- c()
(cor_mat2 <- round(cor_mat, 2))
```

The determinant of the correlation matrix not zero, the matrix has an inverse

```{r message=FALSE, warning=FALSE}
library(matlib)
det(cor_mat2) # get determinant
(cor_inv <- inv(cor_mat2)) # get the inverse matrix
(by_inv <- cor_mat2 %*% cor_inv)
(res <- round(by_inv, 1))
```

get the inverse 
```{r message=FALSE, warning=FALSE}
library(matrixcalc)
# LU decomposition 

(cor_lu <- lu.decomposition(cor_mat2))
# multiply L and U 
# 
(cor_lu$L %*% cor_lu$U) 

```


**Calculus-Based Probability & Statistics.**  Many times, it makes sense to fit a closed form distribution to data.  Select a variable in the Kaggle.com training dataset that is skewed to the right, shift it so that the minimum value is absolutely above zero if necessary.  Then load the MASS package and run fitdistr to fit an exponential probability density function.  (See  https://stat.ethz.ch/R-manual/R-devel/library/MASS/html/fitdistr.html ).  Find the optimal value of λ for this distribution, and then take 1000 samples from this exponential distribution using this value (e.g., rexp(1000, λ)).  Plot a histogram and compare it with a histogram of your original variable. Using the exponential pdf, find the 5th and 95th percentiles using the cumulative distribution function (CDF).   Also generate a 95% confidence interval from the empirical data, assuming normality.  Finally, provide the empirical 5th percentile and 95th percentile of the data.  Discuss.



```{r}
fit_data <- train$MasVnrArea
fit_data <- fit_data[complete.cases(fit_data)]
hist(fit_data)
summary(fit_data)
```

```{r}
length(fit_data[fit_data == 0])
```
Out of the 1452 houses, there are 861 that have no masonry veneers (area is zero).


Because the data measures area, adding a value of .01 should be negligible and would get rid of the zero values. A property with a masonry veneer area of .01 square feet would mean this property does not really have any masonry veneer.


```{r}
fit_data <- fit_data + .01
hist(fit_data)
summary(fit_data)
```

```{r message=FALSE, warning=FALSE}
library(MASS)
fit <- fitdistr(fit_data, densfun = "exponential")
# the optimal value
fit$estimate
```

```{r}
exp <- rexp(length(fit_data), rate = fit$estimate) 
hist(exp)
```

```{r}
qexp(.05, rate=fit$estimate)
qexp(.95, rate=fit$estimate)
```

```{r}
norm.interval = function(data, variance = var(data), conf.level = 0.95) 
{
      z = qnorm((1 - conf.level)/2, lower.tail = FALSE)
      xbar = mean(data)
      sdx = sqrt(variance/length(data))
      c(xbar - z * sdx, xbar + z * sdx)
}

norm.interval(fit_data, variance=var(fit_data), conf.level = 0.95)
```


```{r}
quantile(x=fit_data, probs=c(.05, .95))
```



